# Summary Analysis of the major exploits that took place on Ethereum

Each exploit has a more detailed analysis in its own folder, with the vulnerabilities of the contract(s) and the transaction the hacker made to exploit them.

## TempleDAO - 1,830 ETH (2022-10-11)


### The vulnerability: Access control 

Poor access control on the `migrateStake()` function of StaxLPStaking:

```solidity
    /**
     * @notice For migrations to a new staking contract:
     *         1. User/DApp checks if the user has a balance in the `oldStakingContract`
     *         2. If yes, user calls this function `newStakingContract.migrateStake(oldStakingContract, balance)`
     *         3. Staking balances are migrated to the new contract, user will start to earn rewards in the new contract.
     *         4. Any claimable rewards in the old contract are sent directly to the user's wallet.
     * @param oldStaking The old staking contract funds are being migrated from.
     * @param amount The amount to migrate - generally this would be the staker's balance
     */
function migrateStake(address oldStaking, uint256 amount) external {
    StaxLPStaking(oldStaking).migrateWithdraw(msg.sender, amount); //exploit
    _applyStake(msg.sender, amount);
}
```

This function allows **anyone** (missing modifier) to submit **any address** (missing check) as the `oldStaking` parameter.

The first line call `migrateWithdraw` on the *supplied address*, anyone can choose what this functin does (eg nothing at all), and the second line increase the msg.sender's balance on the contract, since the contract thinks that the msg.sender had something staked that was just migrate:
```solidity
function _applyStake(address _for, uint256 _amount) internal updateReward(_for) {
    _totalSupply += _amount;
    _balances[_for] += _amount;
    emit Staked(_for, _amount);
}
```

Once this is done, we can just call `withdrawAll()` which will transfer the given amount of LP tokens to our msg.sender address.

![Exploit tx](TempleDAO/img/exploit_tx.png "Exploit tx")

---------


## Meebits - 200ETH (2021-05-08)

In May 2021, an attacker, armed with the list of rare Meebits tokenIds, managed to brute force the early mint of the NFT and revert all transactions except the ones that would mint a rare NFT. He managed to mint one before the mint was paused, and sold it for 200 ETH.

### The vulnerability: leaked rarity traits

Inside a NFT collection, some token are more rare than others, and thus more valuable. The rarity is baseed on the token's traits. Unfortunately, for the Meebits NFT, the contract contained a file with the metadata of the collection, containing the traits and their rarity for each tokenId. So when you minted an NFT, you could know its relative value.

```solidity
// IPFS Hash to the NFT content
    string public contentHash =
        "QmfXYgfX1qNfzQ6NRyFnupniZusasFPMeiWn5aaDnx7YXo";
```

Since the `mint()` function returns the id of the minted token, a contract could easily call the `mint()` function and `revert` if the returned id was not in a list of rare tokenId.

### The exploit

The attacker deployed his attack contract, with a list of rare tokenId, and an `attack()` function which simply called `mintWithPunkOrGlyph()` and made sure the minted token was rare, otherwise the tx would revert. It also sent 1 ETH to the miner to ensure that the transaction would be added to the block:

```solidity
function attack(uint _punkId) public{
    uint256 tokenId = meebits.mintWithPunkOrGlyph(_punkId); // mint a meebits
    require(rareMeebits[tokenId]); //check if its a rare one, revert if not
    block.coinbase.call{value: 1 ether}(""); // pay the miner
}
```

![Successful mint transaction](Meebits/img/successful_brute_force_mint.png "Successful mint transaction")

He then quickly sold Meebits #16647 for 200 ETH.

---------


## Multi-sig Wallet - 150,000 ETH (2017-07-19)


The multi sig wallet works with a library and use `delegatecall`. If someone calls `initWallet()` on the Wallet, it will delegate the call to the Library which will execute **within the context** of the Wallet contract:
```solidity
function initWallet(
    address[] _owners,
    uint256 _required,
    uint256 _daylimit
) {
    initMultiowned(_owners, _required); //sett owner and n. of required sig
    initDaylimit(_daylimit); // set daily limit for withdraw
}
```
With `initMultiowned()`:
```solidity
// constructor is given number of sigs required to do protected "onlymanyowners" transactions
// as well as the selection of addresses capable of confirming them.
// change from original: msg.sender is not automatically owner
function initMultiowned(address[] _owners, uint256 _required) {
    m_numOwners = _owners.length; //1
    m_required = _required; //0

    for (uint256 i = 0; i < _owners.length; ++i) {
        m_owners[1 + i] = uint256(_owners[i]); //attacker becomes owner
        m_ownerIndex[uint256(_owners[i])] = 1 + i;
    }
}
```
So by calling `initWallet([attacker_addr], 0,_)`, the attacker becomes owner of the Wallet, change the number of signature required to 0 and the daily limit of widrawnable funds to the balance of the wallet. He can then withdraw the funds by calling `execute(attacker_addr, amount, _)`:
```solidity
    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.
    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
    // and _data arguments). They still get the option of using them if they want, anyways.
    function execute(
        address _to,
        uint256 _value,
        bytes _data
    ) onlyowner returns (bool _callValue) {
        // first, take the opportunity to check that we're under the daily limit.
        if (underLimit(_value)) {
            SingleTransact(msg.sender, _value, _to, _data);
            // yes - just execute the call.
            _callValue = _to.call.value(_value)(_data); // transfer funds to attacker
        } else {...}
    }
```


![Init transaction](MultiSig/img/init_tx.png "Init transaction")
