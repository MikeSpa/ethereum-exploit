# Analysis of the Parity Bug

After the MultiSig attack of July 2017 (where anyone could reinitialize any multisig wallet thanks to `initWallet()`, become owner, and withdraw all funds), the Parity team deployed their new Parity wallet library with the previous vulnerability "fixed":
```js
// constructor - just pass on the owner array to the multiowned and
    // the limit to daylimit
    function initWallet(
        address[] _owners,
        uint256 _required,
        uint256 _daylimit
    ) only_uninitialized { // can only be initialized once and since this function was called in the *Wallet* constructor, they thought they were safe
        initDaylimit(_daylimit);
        initMultiowned(_owners, _required);
    }

```
A few month later, a user "accidentally" managed to suicide the library contract by calling the very same `initWallet()` function, since there had been no initialization on the library contract.

## Addresses involved
The exploited *Library* contract i.e. ParityBug: Trigger: [0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4](https://etherscan.io/address/0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4#code)  
Polkadot: MultiSig, one of the victim *Wallet*: [0x3BfC20f0B9aFcAcE800D73D2191166FF16540258](https://etherscan.io/address/0x3bfc20f0b9afcace800d73d2191166ff16540258#code)  
The initWallet tx: [0x05f71e1b2cb4f03e547739db15d080fd30c989eda04d37ce6264c5686e0722c9](https://etherscan.io/tx/0x05f71e1b2cb4f03e547739db15d080fd30c989eda04d37ce6264c5686e0722c9)  
The selfdestruct tx: [0x47f7cff7a5e671884629c93b368cb18f58a993f4b19c2a53a8662e3f1482f690](https://etherscan.io/tx/0x47f7cff7a5e671884629c93b368cb18f58a993f4b19c2a53a8662e3f1482f690)  

The attacker address: [0xae7168deb525862f4fee37d987a971b385b96952](https://etherscan.io/address/0xae7168deb525862f4fee37d987a971b385b96952)  

[153 victim contractss on Etherscan](https://etherscan.io/accounts/label/parity-bug)

## The vulnerability: Uninitialization 

The main vulnerability again involve `initWallet()`, only now it can only be called once. The function was correctly written, from the point of view of the Wallet contract, to make it uncallable after been initialized once. But since it was never called on the library contract itself, any one could call it and become owner of the **library**. Becoming owner of the library is not very interesting, you can change the library storage a bit but that is all.  
The big problem comes from the fact that the contract was a library, which was used by a lot (500+) of different Parity Wallet smart contract. If this library were to disappear (become uncallable) those contracts who rely on it for their logic would simply become unusable.  
The library have a `kill()` function that call `selfdestruct()` (`suicide()`). It is protected by ownership, but since `initWallet()` can give ownership to anyone, the first user to call `initWallet()` can now destroy the library and all attached contracts.

When the library gets killed, all contracts whose functions `delegatecall()` to it will no longer work. Since, in the Parity Wallet, the library address is a constant variable and thus hardcoded in the bytecode of the contract once deploy:
```js
address constant _walletLibrary = 0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4;
```
those contracts become completely unusable.



## The exploit

The attacker first called `initWallet([attacker_addr],0,0)`

![initWallet transaction](ParityBug/img/initWallet.png "initWallet transaction")

which was never(!) called before,
`initWallet()`:
```js
// throw unless the contract is not yet initialized.
modifier only_uninitialized() {
    if (m_numOwners > 0) throw;
    _;
}

function initWallet(
    address[] _owners,
    uint256 _required,
    uint256 _daylimit
) only_uninitialized { //modifier doesn't throw since m_numOwners on the library storage was equal to zero
    initDaylimit(_daylimit);
    initMultiowned(_owners, _required); // attacker becomes owner
}

function initMultiowned(address[] _owners, uint256 _required)
    only_uninitialized
{
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint256(msg.sender);
    m_ownerIndex[uint256(msg.sender)] = 1;
    for (uint256 i = 0; i < _owners.length; ++i) {
        m_owners[2 + i] = uint256(_owners[i]);
        m_ownerIndex[uint256(_owners[i])] = 2 + i;
    }
    m_required = _required;
}
```
This allowed him to become owner of the library, he could then call `kill()` on the library:

![Kill transaction](img/kill.png "Kill transaction")

```js
// kills the contract sending everything to `_to`.
function kill(address _to) external onlymanyowners(sha3(msg.data)) { // onlymanyowners modifier
    suicide(_to);
}

modifier onlymanyowners(bytes32 _operation) {
    if (confirmAndCheck(_operation)) _;
}

function confirmAndCheck(bytes32 _operation) internal returns (bool) {
    // determine what index the present sender is:
    uint256 ownerIndex = m_ownerIndex[uint256(msg.sender)]; //** set in initMultiowned
    // make sure they're an owner
    if (ownerIndex == 0) return; // ** false

    ... // ** nothing much happen after that, the function finishes and return true
}
```

The library is now gone and all contracts whose functions `delegatecall()` to it will no longer work. 

The attacker then open an issue on Github to report his findings:

![Issue on GitHub](img/github.png "Issue on GitHub")



## The Aftermath

Parity: "All dependent multi-sig wallets that were deployed after 20th July functionally now look as follows:
```solidity
contract Wallet {
    function () payable {
        Deposit(...)
    }
 }
 ```
 This means that currently no funds can be moved out of the multi-sig wallets."

Overall over 500,000 ETH in more than 500 different wallet have been lost, stuck on these contract and completely unaccessible. The biggest lose was [Polkadot](https://etherscan.io/address/0x3bfc20f0b9afcace800d73d2191166ff16540258#code) who lost over 300,000 ETH.


## Sources
Parity blog post:
[Security Alert](https://www.parity.io/blog/security-alert)  
[Security Alert 2](https://www.parity.io/blog/security-alert-2/)
[Parity Technologies Multi-Sig Wallet Issue Update](https://www.parity.io/blog/parity-technologies-multi-sig-wallet-issue-update/)  
[A Postmortem on the Parity Multi-Sig Library Self-Destruct](https://www.parity.io/blog/a-postmortem-on-the-parity-multi-sig-library-self-destruct/)  
[On Classes of Stuck Ether and Potential Solutions](https://www.parity.io/blog/on-classes-of-stuck-ether-and-potential-solutions/)  

[Github issue first mentioning the problem](https://github.com/openethereum/parity-ethereum/issues/6995)