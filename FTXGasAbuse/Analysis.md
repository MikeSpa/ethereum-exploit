# Analysis of the FTX Exchange Gas Abuse
In October 2022, a user abused free gas, offer by the FTX exchange for their withdraw, to mint XEN token, which requires no ETH, only gas for the transaction. It costed FTX over 81 ETH in gas fee and the exploiter made over 61 ETH by swapping the obtain XEN for ETH, WBTC and USDC.

## Addresses involved
The FTX Exchange address: [0xC098B2a3Aa256D2140208C3de6543aAEf5cd3A94](https://etherscan.io/address/0xC098B2a3Aa256D2140208C3de6543aAEf5cd3A94)  
The XEN contract: [0x06450dEe7FD2Fb8E39061434BAbCFC05599a6Fb8](https://etherscan.io/address/0x06450dEe7FD2Fb8E39061434BAbCFC05599a6Fb8#code)  

One of the ClaimRank tx: [0xe3bef0cb7b7c9415ed53c29b4495672ffcef318d2be22da434ed12aef1ca9f11](https://etherscan.io/tx/0xe3bef0cb7b7c9415ed53c29b4495672ffcef318d2be22da434ed12aef1ca9f11)  
One of the claimMintReward tx: [0xb6d42419b3d280ea0be680c0e8839bc252c877a731fba50f5b8d46cb1d8e98b3](https://etherscan.io/tx/0xb6d42419b3d280ea0be680c0e8839bc252c877a731fba50f5b8d46cb1d8e98b3)  
One of the swap tx: [0x199ba78683c8ede6f69c91cb6c51aaa4da4dbe7b2164c87a7a673dc860bcda50](https://etherscan.io/tx/0x199ba78683c8ede6f69c91cb6c51aaa4da4dbe7b2164c87a7a673dc860bcda50)  

The exploiter address: [0x1d371CF00038421d6e57CFc31EEff7A09d4B8760](https://etherscan.io/address/0x1d371CF00038421d6e57CFc31EEff7A09d4B8760)  
The exploit contract: [0xCba9b1Fd69626932c704DAc4CB58c29244A47FD3](https://etherscan.io/address/0xCba9b1Fd69626932c704DAc4CB58c29244A47FD3)  

## The vulnerability: Gas limit too high on withdraw 

The FTX exchange offer free withdraw (transaction sent from the FTX address), with a transaction where the gas limit is set to 500'000. The withdraw transaction call the `fallback()` function on the address where the funds are to be sent, if the address is a contract, it will then executed whatever code is in that function until the gas runs out. With a gas limit of 500'000, there is a lot of gas left after the ETH transfer. A user can then use that gas to do anything they want.

The XEN token doesn't necessary have a vulnerability. It was used as intended, except they probably didn't expect a user to have access to free gas. The users can mint token with `claimRank(uint256 term)`:
```solidity
function claimRank(uint256 term) external {
    uint256 termSec = term * SECONDS_IN_DAY; //** minimum waiting period is a day
    require(termSec > MIN_TERM, "CRank: Term less than min");
    require(
        termSec < _calculateMaxTerm() + 1,
        "CRank: Term more than current max term"
    );
    require(
        userMints[_msgSender()].rank == 0, //** only one mint at a time
        "CRank: Mint already in progress"
    );

    // create and store new MintInfo
    MintInfo memory mintInfo = MintInfo({
        user: _msgSender(),
        term: term,
        maturityTs: block.timestamp + termSec,
        rank: globalRank,
        amplifier: _calculateRewardAmplifier(),
        eaaRate: _calculateEAARate()
    });
    userMints[_msgSender()] = mintInfo;exploit
    activeMinters++;
    emit RankClaimed(_msgSender(), term, globalRank++);
}
```
wait `term` days, and then the user can claim their token with `claimMintReward()` or `claimMintRewardAndShare(receiverAddr, splitPerCentage)`. Those functions are similar, except that with the latter you can send the token to another address (or split them). The exploiter will use this to sent himself the token since he will mint them with a bunch of contracts that will self-destruct:
```solidity
function claimMintRewardAndShare(address other, uint256 pct) external {
    MintInfo memory mintInfo = userMints[_msgSender()];
    require(other != address(0), "CRank: Cannot share with zero address");
    require(pct > 0, "CRank: Cannot share zero percent");
    require(pct < 101, "CRank: Cannot share 100+ percent");
    require(mintInfo.rank > 0, "CRank: No mint exists");
    require(
        block.timestamp > mintInfo.maturityTs,  //** check waiting period
        "CRank: Mint maturity not reached"
    );

    // calculate reward
    uint256 rewardAmount = _calculateMintReward(
        mintInfo.rank,
        mintInfo.term,
        mintInfo.maturityTs,
        mintInfo.amplifier,
        mintInfo.eaaRate
    ) * 1 ether;
    uint256 sharedReward = (rewardAmount * pct) / 100;
    uint256 ownReward = rewardAmount - sharedReward;

    // mint reward tokens
    _mint(_msgSender(), ownReward);
    _mint(other, sharedReward);

    _cleanUpUserMint();
    emit MintClaimed(_msgSender(), rewardAmount);
}
```

## The exploit

A user decided to use that free gas to mint some XEN. XEN is an ERC-20 token where the mint function requires no ETH just the gas needed for the transaction.  
The exploiter deployed an exploitContract and made the FTX exchange send it some ETH.
When the FTX exchange called the exploitContract `fallback()` function to sent some ETH (0.0035ETH), the exploitContract will use as much as the 500'000 gas limit to mint XEN tokens. It first deploys a dummy contract, mint the token with `XEN.claimRank(1)` with this contract and then selfdestruct. He finally send the received ETH to the exploiterAddr. Since some gas is left, he does it again with other dummy contracts. An address can only do one mint at the time, and has to wait at least a day until it can withdraw the token to mint again. He did dozens of similar transactions. All gas fee are paid by the FTX exchange.

![claimRank transaction](img/claimRanktx.png "claimRank transaction")

After a day, the tokens can be claimed, so the contracts will now call `XEN.claimMintRewardAndShare(exploiterAddr, 100)`, claiming their token and sharing them all with the exploiter address. It will then remint some token (and claim them a day later). Finally it selfdestruct the dummyContract. Since at this point there is still some unused gas, he does the same two more time with two other dummy contracts. At the end, the `fallback()` function send the received 0.0035ETH to the exploiter address. Again, since the FTX address is the sender of the transaction, so it pays all the gas fee.

![claimMintReward transaction](img/claimMintRewardtx.png "claimMintReward transaction")

In one transaction, the exploiter ends up with around 171,000 XEN, the FTX address loses around 0.01 ETH in gas fee.

He then started to do call his exploitContract himself and creating dozens of dummyContracts and netting over 5MM of XEN per transaction.

![transaction 2](img/tx2.png "transaction 2")


## The aftermath

The exploiter costed FTX over 81 ETH in transactions fee and earned over 61 ETH by swapping the XEN token for ETH, WBTC and USDC.