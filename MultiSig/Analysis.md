# Analysis of the Multi-Sig exploit 

Attacker address: [0xB3764761E297D6f121e79C32A65829Cd1dDb4D32](https://etherscan.io/address/0xb3764761e297d6f121e79c32a65829cd1ddb4d32?fromaddress=0xB3764761E297D6f121e79C32A65829Cd1dDb4D32)  
Victim contract #1: [0x91EFffB9C6cd3A66474688D0a48AA6ECfe515AA5](https://etherscan.io/address/0x91efffb9c6cd3a66474688d0a48aa6ecfe515aa5#code)  
Wallet Library: [0x4f2875f631f4fc66b8e051defba0c9f9106d7d5a](https://etherscan.io/address/0x4f2875f631f4fc66b8e051defba0c9f9106d7d5a#code)

## The vulnerability: Delegate Call with multiple Initializatons possible

The multi sig wallet works with a library and use `delegatecall`. If someone calls `initWallet()` on the Wallet, it will delegate the call to the Library which will execute **within the context** of the Wallet contract:
```solidity
function initWallet(
    address[] _owners,
    uint256 _required,
    uint256 _daylimit
) {
    initMultiowned(_owners, _required); //sett owner and n. of required sig
    initDaylimit(_daylimit); // set daily limit for withdraw
}
```
With `initMultiowned()`:
```solidity
// constructor is given number of sigs required to do protected "onlymanyowners" transactions
// as well as the selection of addresses capable of confirming them.
// change from original: msg.sender is not automatically owner
function initMultiowned(address[] _owners, uint256 _required) {
    m_numOwners = _owners.length; //1
    m_required = _required; //0

    for (uint256 i = 0; i < _owners.length; ++i) {
        m_owners[1 + i] = uint256(_owners[i]); //attacker becomes owner
        m_ownerIndex[uint256(_owners[i])] = 1 + i;
    }
}
```
So by calling `initWallet([attacker_addr], 0,_)`, the attacker becomes owner of the Wallet, change the number of signature required to 0 and the daily limit of widrawnable funds to the balance of the wallet. He can then withdraw the funds by calling `execute(attacker_addr, amount, _)`:
```solidity
    // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.
    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide
    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value
    // and _data arguments). They still get the option of using them if they want, anyways.
    function execute(
        address _to,
        uint256 _value,
        bytes _data
    ) onlyowner returns (bool _callValue) {
        // first, take the opportunity to check that we're under the daily limit.
        if (underLimit(_value)) {
            SingleTransact(msg.sender, _value, _to, _data);
            // yes - just execute the call.
            _callValue = _to.call.value(_value)(_data); // transfer funds to attacker
        } else {...}
    }
```


## The Exploit
The attacker send a first transaction `initWallet` to become owner, and then a second `execute` to withdraw the funds:

![Transactions](img/attacker_txs.png "Transactions")
After that he received the ETH on his account.

The first transaction calls `initWallet([attacker_addr], 0, amount_to_withdraw)`, since Wallet doesn't have this function signature, it delegate the call to the WalletLibrary which end up modifying the variable in Wallet
![Init transaction](img/init_tx.png "Init transaction")

The second transaction calls `execute(attacker_addr, balanceOf(contract)` which once again will get delegated to the library which will transfer the amount given as argument to the address given as parameter.
![Execute transaction](img/execute_tx.png "Execute transaction")

## The Aftermath
The same attack was executed on three similar wallet, for a total of over 150,000 ETH. There is still about 83,000 ETH in the hacker account ($107,371,137 at this time) while arount 70,000 ETH have been transfer to other EOA.